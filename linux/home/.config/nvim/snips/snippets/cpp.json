{
	"SimpleCode": {
		"prefix": "SimpleCode",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#ifndef ONLINE_JUDGE",
			"#include \"debug.h\"",
			"#else",
			"#define debug(...)",
			"#endif",
			"",
			"template <typename _Ty>",
			"constexpr _Ty inf = std::numeric_limits<_Ty>::max() / 2;",
			"using u8 = uint8_t;",
			"using i64 = int64_t;",
			"",
			"using namespace std;",
			"",
			"auto Main() -> void {",
			"\t$0",
			"}",
			"",
			"auto main() -> int {",
			"\tstd::ios_base::sync_with_stdio(false);",
			"\tstd::cin.tie(nullptr);",
			"\tstd::cout << std::fixed << std::setprecision(15);",
			"",
			"\tint test = 1;",
			"\tstd::cin >> test;",
			"",
			"\tfor (int t = 0; t < test; t ++) {",
			"\t\tMain();",
			"\t}",
			"}"
		],
		"description": "Simple Code"
	},
	"Disjoin Set Uion": {
		"prefix": "DisjoinSetUion",
		"body": [
			"class DisjointSet {",
			"private:",
			"\tstd::vector<int> _dad;",
			"\tstd::size_t _setCount;",
			"",
			"public:",
			"\texplicit DisjointSet(std::size_t __size)",
			"\t\t: _dad(__size, -1), _setCount(__size) {}",
			"",
			"private:",
			"\tauto _InRange(int __x) const -> bool { return 0 <= __x && __x < _dad.size(); }",
			"",
			"\tauto _GetLeader(int __x) -> int {",
			"\t\tif (_dad[__x] <= -1) {",
			"\t\t\treturn __x;",
			"\t\t}",
			"\t\treturn _dad[__x] = _GetLeader(_dad[__x]);",
			"\t}",
			"",
			"\tauto _GetCount(int __x) -> int { return -_dad[_GetLeader(__x)]; }",
			"",
			"\ttemplate <typename __compare>",
			"\tauto _MergeIf(int __a, int __b, const __compare &comp) -> bool {",
			"\t\t__a = _GetLeader(__a);",
			"\t\t__b = _GetLeader(__b);",
			"\t\tif (!comp(__a, __b)) {",
			"\t\t\tstd::swap(__a, __b);",
			"\t\t}",
			"\t\tif (!comp(__a, __b)) {",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\t_dad[__a] += _dad[__b];",
			"\t\t_dad[__b] = __a;",
			"\t\t--_setCount;",
			"\t\treturn true;",
			"\t}",
			"",
			"\tauto _MergeTo(int __a, int __b) -> bool {",
			"\t\t__a = _GetLeader(__a);",
			"\t\t__b = _GetLeader(__b);",
			"\t\tif (__a == __b) {",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\t_dad[__b] += _dad[__a];",
			"\t\t_dad[__a] = __b;",
			"\t\t--_setCount;",
			"\t\treturn true;",
			"\t}",
			"",
			"public:",
			"\tauto GetLeader(int __x) -> int {",
			"\t\tassert(_InRange(__x));",
			"\t\treturn _GetLeader(__x);",
			"\t}",
			"",
			"\tauto GetCount() const -> std::size_t { return _setCount; }",
			"",
			"\tauto GetCount(int __x) -> int {",
			"\t\tassert(_InRange(__x));",
			"\t\treturn _GetCount(__x);",
			"\t}",
			"",
			"\ttemplate <typename __compare>",
			"\tauto MergeIf(int __a, int __b, const __compare &__comp) -> bool {",
			"\t\tassert(_InRange(__a));",
			"\t\tassert(_InRange(__b));",
			"\t\treturn _MergeIf(__a, __b, __comp);",
			"\t}",
			"",
			"\tauto MergeTo(int __a, int __b) -> bool {",
			"\t\tassert(_InRange(__a));",
			"\t\tassert(_InRange(__b));",
			"\t\treturn _MergeTo(__a, __b);",
			"\t}",
			"",
			"\tauto IsSame(int __a, int __b) -> bool {",
			"\t\tassert(_InRange(__a));",
			"\t\tassert(_InRange(__b));",
			"\t\treturn _GetLeader(__a) == _GetLeader(__b);",
			"\t}",
			"",
			"\tauto Assign(std::size_t __size) -> void {",
			"\t\t_dad.assign(__size, -1);",
			"\t\t_setCount = __size;",
			"\t}",
			"};"
		],
		"description": "Disjoin Set Uion"
	},
	"FenwickTree": {
		"prefix": "FenwickTree",
		"body": [
			"#if __cplusplus >= 202002L",
			"template <",
			"\ttypename Type,",
			"\tstd::regular_invocable<Type,Type> Operator = std::plus<Type>",
			">",
			"#else",
			"template <",
			"\ttypename Type,",
			"\ttypename Operator = std::plus<Type>,",
			"\tstd::enable_if<std::is_invocable<Operator,Type,Type>::value>* = nullptr",
			">",
			"#endif",
			"class FenwickTree {",
			"public:",
			"\texplicit FenwickTree(int size) : FenwickTree(size, Type{}, Operator{}) {}",
			"",
			"\texplicit FenwickTree(int size, Type initValue) : FenwickTree(size, initValue, Operator{}) {}",
			"",
			"\texplicit FenwickTree(int size, Type initValue, Operator opt)",
			"\t\t: bit(size + 1, initValue), opt(opt) {}",
			"",
			"\tvoid Assign(int size, Type value) {",
			"\t\tbit.Assign(size, value);",
			"\t}",
			"",
			"\tvoid Update(int idx, Type dx) {",
			"\t\tfor (int i = idx + 1; i < (int)bit.size(); i += Lowbit(i)) {",
			"\t\t\tbit[i] = opt(bit[i], dx);",
			"\t\t}",
			"\t}",
			"",
			"\tvoid Fill(Type value) {",
			"\t\tstd::fill(bit.begin(), bit.end(), value);",
			"\t}",
			"",
			"\tType Get(int idx, Type result = {}) const {",
			"\t\tfor (int i = idx + 1; i > 0; i -= Lowbit(i)) {",
			"\t\t\tresult = opt(result, bit[i]);",
			"\t\t}",
			"\t\treturn result;",
			"\t}",
			"",
			"private:",
			"\tconstexpr static int Lowbit(int x) noexcept {",
			"\t\treturn x & -x;",
			"\t}",
			"",
			"\tstd::vector<Type> bit;",
			"\tOperator opt;",
			"};"
		],
		"description": "FenwickTree"
	},
	"AutoModInt": {
		"prefix": "AutoModInt",
		"body": [
			"template <std::integral auto _P>",
			"\trequires(_P >= 1)",
			"struct ModInt {",
			"private:",
			"\tusing u32 = uint32_t;",
			"\tusing i32 = int32_t;",
			"\tusing u64 = uint64_t;",
			"\tusing i64 = int64_t;",
			"\tusing i128 = __int128_t;",
			"\tusing u128 = __uint128_t;",
			"",
			"public:",
			"\tusing value_type = decltype(_P);",
			"",
			"private:",
			"\tvalue_type _value;",
			"",
			"public:",
			"\tinline static constexpr auto P = _P;",
			"",
			"public:",
			"\tconstexpr ModInt() noexcept : _value(0) {}",
			"",
			"\tconstexpr ModInt(std::integral auto value) noexcept {",
			"\t\t_value = value % P;",
			"\t\tif (_value < 0)",
			"\t\t\t_value += P;",
			"\t}",
			"",
			"\texplicit constexpr operator int() const noexcept {",
			"\t\treturn _value;",
			"\t}",
			"",
			"\texplicit constexpr operator long long() const noexcept {",
			"\t\treturn _value;",
			"\t}",
			"",
			"\texplicit constexpr operator bool() const noexcept {",
			"\t\treturn _value > 0;",
			"\t}",
			"",
			"\tconstexpr auto operator==(const ModInt &other) const noexcept -> bool {",
			"\t\treturn _value == other._value;",
			"\t}",
			"",
			"\tconstexpr auto operator!=(const ModInt &other) const noexcept -> bool {",
			"\t\treturn _value != other._value;",
			"\t}",
			"",
			"\tconstexpr auto operator-() const noexcept -> ModInt {",
			"\t\treturn ModInt{_value ? P - _value : 0};",
			"\t}",
			"",
			"\tconstexpr auto operator+() const noexcept -> ModInt {",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tconstexpr auto operator++() noexcept -> ModInt & {",
			"\t\t++_value;",
			"\t\tif (_value == P)",
			"\t\t\t_value = 0;",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tconstexpr auto operator--() noexcept -> ModInt & {",
			"\t\tif (_value == 0)",
			"\t\t\t_value = P;",
			"\t\t--_value;",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tconstexpr auto operator++(int) noexcept -> ModInt {",
			"\t\tauto prev = *this;",
			"\t\t++*this;",
			"\t\treturn prev;",
			"\t}",
			"",
			"\tconstexpr auto operator--(int) noexcept -> ModInt {",
			"\t\tauto prev = *this;",
			"\t\t--*this;",
			"\t\treturn prev;",
			"\t}",
			"",
			"\tconstexpr auto operator+=(const ModInt &other) noexcept -> ModInt & {",
			"\t\t_value += other._value;",
			"\t\tif (_value >= P)",
			"\t\t\t_value -= P;",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tconstexpr auto operator+(const ModInt &other) const noexcept -> ModInt {",
			"\t\tauto result = *this;",
			"\t\tresult += other;",
			"\t\treturn result;",
			"\t}",
			"",
			"\tconstexpr auto operator-=(const ModInt &other) noexcept -> ModInt & {",
			"\t\t_value -= other._value;",
			"\t\tif (_value < 0)",
			"\t\t\t_value += P;",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tconstexpr auto operator-(const ModInt &other) const noexcept -> ModInt {",
			"\t\tauto result = *this;",
			"\t\tresult -= other;",
			"\t\treturn result;",
			"\t}",
			"",
			"\tconstexpr auto operator*=(const ModInt &other) noexcept -> ModInt & {",
			"\t\tif constexpr (std::is_same_v<value_type, i32> || std::is_same_v<value_type, int> ||",
			"\t\t\t\t\t  std::is_same_v<value_type, u32>) {",
			"\t\t\t_value = (value_type)(((u64)_value * other._value) % P);",
			"\t\t} else if (std::is_same_v<value_type, i64> || std::is_same_v<value_type, u64> ||",
			"\t\t\t\t   std::is_same_v<value_type, long long>) {",
			"\t\t\t_value = (value_type)((u128)_value * other._value) % P;",
			"\t\t} else {",
			"\t\t\t_value = _SlowMut(_value, other._value);",
			"\t\t}",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tconstexpr auto operator*(const ModInt &other) const noexcept -> ModInt {",
			"\t\tauto result = *this;",
			"\t\tresult *= other;",
			"\t\treturn result;",
			"\t}",
			"",
			"\tconstexpr auto operator^(std::integral auto i) const noexcept -> ModInt {",
			"\t\treturn _Pow(*this, i);",
			"\t}",
			"",
			"\tconstexpr auto operator^=(std::integral auto i) const noexcept -> ModInt & {",
			"\t\t*this = (*this) ^ i;",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tconstexpr auto operator/=(const ModInt &other) noexcept -> ModInt & {",
			"\t\treturn (*this) *= other.GetInv();",
			"\t}",
			"",
			"\tconstexpr auto operator/(const ModInt &other) const noexcept -> ModInt {",
			"\t\tauto result = *this;",
			"\t\tresult /= other;",
			"\t\treturn result;",
			"\t}",
			"",
			"\tconstexpr auto GetInv() const noexcept -> ModInt {",
			"\t\treturn (*this) ^ (P - 2);",
			"\t}",
			"",
			"\tconstexpr auto GetValue() const noexcept -> value_type {",
			"\t\treturn _value;",
			"\t}",
			"",
			"\tfriend constexpr auto operator+(const ModInt &a, const std::integral auto &b) noexcept -> ModInt {",
			"\t\treturn a + ModInt(b);",
			"\t}",
			"",
			"\tfriend constexpr auto operator+(const std::integral auto &a, const ModInt &b) noexcept -> ModInt {",
			"\t\treturn ModInt(a) + b;",
			"\t}",
			"",
			"\tfriend constexpr auto operator-(const ModInt &a, const std::integral auto &b) noexcept -> ModInt {",
			"\t\treturn a - ModInt(b);",
			"\t}",
			"",
			"\tfriend constexpr auto operator-(const std::integral auto &a, const ModInt &b) noexcept -> ModInt {",
			"\t\treturn ModInt(a) - b;",
			"\t}",
			"",
			"\tfriend constexpr auto operator*(const ModInt &a, const std::integral auto &b) noexcept -> ModInt {",
			"\t\treturn a * ModInt(b);",
			"\t}",
			"",
			"\tfriend constexpr auto operator*(const std::integral auto &a, const ModInt b) noexcept -> ModInt {",
			"\t\treturn ModInt(a) * b;",
			"\t}",
			"",
			"\tfriend constexpr auto operator/(const ModInt &a, const std::integral auto &b) noexcept -> ModInt {",
			"\t\treturn a * ModInt(b).GetInv();",
			"\t}",
			"",
			"\tfriend constexpr auto operator/(const std::integral auto &a, const ModInt &b) noexcept -> ModInt {",
			"\t\treturn ModInt(a) * b.GetInv();",
			"\t}",
			"",
			"\tconstexpr auto operator~() const noexcept -> ModInt {",
			"\t\treturn GetInv();",
			"\t}",
			"",
			"\tfriend auto operator>>(std::istream &in, ModInt &x) -> std::istream & {",
			"\t\tvalue_type d;",
			"\t\tin >> d;",
			"\t\tx = ModInt(d);",
			"\t\treturn in;",
			"\t}",
			"",
			"\tfriend auto operator<<(std::ostream &out, const ModInt &x) -> std::ostream & {",
			"\t\tout << x._value;",
			"\t\treturn out;",
			"\t}",
			"",
			"private:",
			"\tinline static constexpr auto _Pow(ModInt a, std::integral auto i) noexcept -> ModInt {",
			"\t\tModInt result = 1;",
			"\t\twhile (i > 0) {",
			"\t\t\tif (i & 1) {",
			"\t\t\t\tresult *= a;",
			"\t\t\t}",
			"\t\t\ta *= a;",
			"\t\t\ti >>= 1;",
			"\t\t}",
			"\t\treturn result;",
			"\t}",
			"",
			"\tinline static constexpr auto _SlowMut(value_type a, std::integral auto i) noexcept -> value_type {",
			"\t\tvalue_type result = 1 % P;",
			"\t\ta %= P;",
			"\t\twhile (i > 0) {",
			"\t\t\tif (i & 1) {",
			"\t\t\t\t(result += a) %= P;",
			"\t\t\t}",
			"\t\t\t(a += a) %= P;",
			"\t\t\ti >>= 1;",
			"\t\t}",
			"\t\treturn result;",
			"\t}",
			"};",
			"using mint = ModInt<int(1e9 + 7)>;",
			""
		],
		"description": "AutoModInt"
	}
}